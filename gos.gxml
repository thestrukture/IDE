<?xml version="1.0" encoding="UTF-8"?>
<gos>
	<!--Stating the deployment type GoS should compile -->
	<!-- Curent valid types are webapp,shell and precursor -->
	<!-- Shell = cli, sort of a GoS(Ghost) in the Shell -->
	<deploy>webapp</deploy>
	<port>8884</port>
	
	<!-- Using import within different tags will have different results -->
	<!-- We going to make the goPkg Mongo Db Driver available to our application -->
	<!-- Using <import/> within the <go/> tag is similar to using the import call within a .go file -->
	<!-- To be less dramating, GoS will skip packages that it has already imported -->
	
	<import src="reflect" />
	<import src="encoding/gob" />
	<import src="io/ioutil" />
	<import src="crypto/sha512" />
	<!--<import src="encoding/xml" />-->
	<import src="log" />
	<import src="html" />
	<import src="time" />
    <import src="gopkg.in/mgo.v2/bson"/>
    <import src="github.com/cheikhshift/gos/core"/>
    <import src="os" />
    <import src="strconv" />
    <import src="strings" />
    <import src="github.com/gorilla/websocket" />
    <import src="path/filepath" />
	<import src="runtime"/>
	<import src="github.com/adlane/exec"/>
	<output>server_out.go</output>
	<var type="bool">Windows</var>
	<var type="string">autocompletePath</var>
	<var type="">upgrader = websocket.Upgrader{}</var>
	<var type="">portCount = 35000</var>
	<var type="string">dfd</var>
	<key>something-secretive-is-what-a-gorrilla-needs</key>
	<domain></domain>
	<!-- The <init/> tag is similar to the init function within Go, -->
	<!-- -->
	<main>
			
			dfd = os.ExpandEnv("$GOPATH")
			Windows = strings.Contains(runtime.GOOS, "windows")
			trailerEx := ""
			
			fmt.Println("Using $GOPATH @ home/workspace")
			if  Windows {
					os.Chdir( os.ExpandEnv("$USERPROFILE") )
					trailerEx = ".exe"
			} else {
					os.Chdir( os.ExpandEnv("$HOME") )
			}
				
				err := os.MkdirAll("workspace/",0700)
				if err != nil {
					fmt.Println(err.Error())
					
				} else {
					//download go
					os.MkdirAll("workspace/src",0700)
					os.MkdirAll("workspace/bin",0700)
					os.MkdirAll("workspace/cache",0700)
					os.MkdirAll("workspace/userData",0700)
					cwd, _ := os.Getwd()
					cwd = cwd + "/workspace"
			 		os.Setenv("GOPATH", cwd)
			 		pathbin := os.ExpandEnv("$PATH")
			 		if Windows {
			 			os.Setenv("PATH", pathbin + ":" +  strings.Replace(cwd + "/bin", "/" , "\\", -1 ) ) 
			 		} else {
			 			os.Setenv("PATH", pathbin + ":" +  cwd + "/bin") 
			 		}
			 		
			 		dfd = cwd
			 		
				}
			

			 	if _, err := os.Stat(os.ExpandEnv("$GOPATH") + "/bin/gocode" + trailerEx); os.IsNotExist(err) {
					fmt.Println("Go code completion not present, installing from github.com/mdempsky/gocode")
					if Windows {
						//
						core.RunCmdSmart("go get -u -ldflags -H=windowsgui github.com/mdempsky/gocode")
					} else {

						_ , err1 := core.RunCmdSmart("go install github.com/mdempsky/gocode@latest")
					    
					    if err1 != nil {
					    	log.Fatal(err1)
					    }
					}

				}


				if _, err := os.Stat(os.ExpandEnv("$GOPATH") + "/bin/dlv" + trailerEx); os.IsNotExist(err) {
					fmt.Println("Delve not present, installing from github.com/go-delve/delve/cmd/dlv")

					_, err1 := core.RunCmdSmart("go install github.com/go-delve/delve/cmd/dlv@latest")

					if err1 != nil {
					    	log.Fatal(err1)
					}

				}
			 	

			 	autocompletePath = filepath.Join(os.ExpandEnv("$GOPATH"), "strukture-autocomplete")

			 	if _, err := os.Stat(autocompletePath); os.IsNotExist(err) {
			 		fmt.Println("Creating autocomplete resource folder at " + autocompletePath)
			 		os.MkdirAll(autocompletePath, 0700)
			 	}

			 	


				
				apps := methods.GetApps()
				newapps := []App{}
				for _, app := range apps {
					if app.Name != "" {
						app.Pid = ""
						newapps = append(newapps, app)
					}
				} 
		methods.SaveApps(newapps)

        log.Println("Strukture up on port 8884")

      	if len(os.Args) == 1  {
      		
      		go func(){

      			dataDir := filepath.Join(dfd, "userData")
      			cache := filepath.Join(dfd, "cache")
      			c := chrome.Command("http://localhost:8884", dataDir, cache)

      			err := c.Run()

      			if err != nil {
      				log.Fatal(err)
      			}

				os.Exit(0)
      		}()	
    	} 
	</main>

	<init>
		gob.Register(&types.SoftUser{})
	</init>

	<!-- Contains interfaces and structs
	 that will be used by the GoS application -->
	<header> 
			<!-- remember to Jumpline when stating methods or different struct attributes, it is vital for our parser \n trick -->
		<struct name="FSCs">
			Path string
			Hide bool
			Form Forms
		</struct>
		<struct name="SearchResult">
			File, Snippet string
			Matches [][]int
		</struct>
		<struct name="Dex">
			Misc string
			Text string
			Link string
		</struct>

		<struct name="SoftUser">
             Username string
             Email string
             Password []byte
             Apps []App
             Docker string
             TrialEnd int64
             StripeID,FLogin string
		</struct>


		<struct name="USettings">
			LastPaid string
			Email string
			StripeID string
		</struct>

		<struct name="App">
			Type string
			Name string
			PublicName string
			Css []string
			Groups []string
			Passed,Running bool
			LatestBuild,Pid string
		</struct>

		<struct name="TemplateEdits">
			SavesTo,PKG,PreviewLink,ID,Mime string
			File []byte
			Settings RPut
		</struct>

		<struct name="WebRootEdits">
			SavesTo,Type,PreviewLink,ID,PKG string
			Faas bool
			File []byte
			BreakPoints []byte
		</struct>


	
		<struct name="TEditor">
			PKG,Type,LType string
			CreateForm RPut
		</struct>

		<!-- Boostrap -->
		<struct name="Navbars">
			Mode string
			ID string
		</struct>

		<struct name="sModal">
			Title string
			Body string
			Color string
			Buttons []SButton
			Form Forms
		</struct>

		<struct name="Forms">
			Link string
			Inputs []Inputs
			Buttons []SButton
			CTA string
			Class string
		</struct>

		<struct name="SButton">
			Text string
			Class string
			Link string
		</struct>

	     <struct name="sTab">
			Buttons []SButton
		</struct>

		<struct name="DForm">
			Text,Link string
		</struct>
		

		<struct name="Alertbs">
			Type string
			Text string
			Redirect string
		</struct>

		<struct name="Inputs">
			Misc string
			Text string
			Name string
			Type string
			Options []string
			Value string
		</struct>

		<struct name="Aput">
			Link,Param,Value string
		</struct>

		<struct name="rPut">
			Link string
			DLink string
			Inputs []Inputs
			Count string
			ListLink string
		</struct>

		<struct name="sSWAL">
			Title,Type,Text string
		</struct>

		<struct name="sPackageEdit">
			Type,Mainf,Shutdown,Initf,Sessionf string
			IType,Package,Port,Key,Name,Ffpage,Erpage,Domain Aput
			Css RPut
			Imports []RPut
			Variables []RPut
			CssFiles []RPut
			CreateVar RPut
			CreateImport RPut
			TName string
		</struct>

		<struct name="DebugObj">
		 PKG,Id,Username,RawLog,Time string
		 Bugs []DebugNode
		</struct>

		<struct name="DebugNode">
		 Action,Line,CTA string
		</struct>

	<!-- JSstree struct -->
	

		<struct name="PkgItem">
			ID string  `json:"id"`
			Icon string  `json:"icon"`
			Text string  `json:"text"`
			Children []PkgItem  `json:"children"`
			isXml bool  `json:"isXml"`
			Parent string  `json:"parent"`
			Link string  `json:"link"`
			Type string  `json:"type"`
			DType string  `json:"dtype"`
			RType string  `json:"rtype"`
			NType string  `json:"ntype"`
			MType string  `json:"mtype"`
			CType string  `json:"ctype"`
			AppID string `json:"appid"`
		</struct>

		<!-- Panels for packages -->
		<struct name="sROC">
			Name string
			CompLog []byte
			Build bool
			Time,Pid string
		</struct>

		<struct name="vHuf">
			Type,PKG string
			Edata []byte
		</struct>


		<object struct="Dex" name="myDemoObject">
		
		</object>
	</header>
	<methods>
		<!-- Vars are defined as usual except within the var attribute for example :  -->
		<!-- If there is a basic go function : func hackfmt(data string, data2 string) -->
		<!-- the attribute names would be called as such var="data string,data2 string" -->
		<!-- Similar to a go function decleration-->
		<!--  if a method matches the criteria for an  interface it will be used as an interface method -->
		<!-- To prevent that use the autoface attribute and set it to "false" By default it is true -->
		<!-- Use the keep-local="true" attribute to limit a method within a Go file -->
		
		<!-- Sometimes your method will return data  -->
		<!-- And to do so we will need to add a return var list by using the return attribute  -->
		<method name="BindMisc" var="misc,nav" return="Dex">
				Nav := nav.(Dex)
				Nav.Misc = misc.(string)
				return Nav
		</method>

		<method name="ListPlugins" var="" return="[]string">
			return GetPlugins()	
		</method>

		<method name="BindID" var="id,nav" return="Dex">
				Nav := nav.(Dex)
				Nav.Misc = id.(string)
				return Nav
		</method>

		<method name="RandTen" return="string">
			return core.NewLen(10)
		</method>

	
		<!-- Package methods
			ID string  `json:"id"`
			Icon string  `json:"icon"`
			Text string  `json:"text"`
			Children []PkgItem  `json:"children"`
			isXml bool  `json:"isXml"`
			Link string  `json:"link"`
			Type string  `json:"type"`
			Uses string   -->


		<method name="Fragmentize" var="inn" return="(finall string)">
			finall = strings.Replace(inn.(string), ".tmpl","",-1)
			return 

		</method>


		<method name="parseLog" var="cline" return="string">
			calls := strings.Split(cline.(string) , ":")
			actionText := ""
			if calls[0] == "service" {
				actionText = "The line is located in  Web service ( " + calls[1] +  ") at line: " + calls[2] 
			} else if calls[0] == "init" {
				actionText = "The line is located in your package Init func at line: " + calls[1]
			} else if calls[0] == "main" {
				actionText = "The line is located in your package Main func at line: " + calls[1]
			} else if calls[0] == "structs" {
				actionText = "The line is located in your package Interfaces at line: " + calls[1]
			} else if calls[0] == "meth" {
				actionText = "The line is located in your package template pipelines at line: " + calls[1]
			} 
			return actionText
		</method>

		<method name="AnyBugs" var="packge" return="(ajet bool)" >

			ajet = false //,err := DebugLogs.Find(bson.M{"pkg":packge.(string), "username":usernam.(string)}).Count()

			bugs := GetLogs(packge.(string))

			// local to package invoke directly
			sapp := net_getApp(GetApps(), packge.(string))

			if len(bugs) > 0 {
				ajet = true
			}

			if sapp.Pid != "" {
				ajet = true
			}

			return
		</method>

		<method name="PluginJS" var="" return="string">
			plugins := GetPlugins()
			jsstring := ""
			for _, v := range plugins {
				data, err := ioutil.ReadFile(os.ExpandEnv("$GOPATH") + "/src/" + v + "/index.js")
				if err != nil {
					fmt.Println("Error loading " , v)
				} else {
					jsstring = jsstring + "\n" + string(data)
				}
			}
			return "<script>" + jsstring + "</script>"
		</method>

		<method name="FindmyBugs" var="packge" return="(ajet []DebugObj)">

			ajet =  GetLogs(packge.(string))
			sapp := net_getApp(GetApps(), packge.(string))

			if sapp.Pid != "" {
				activLog := DebugObj{Time:"Server", Bugs:[]DebugNode{} }			
				ajet = append([]DebugObj{activLog}, ajet...)
			}
			return
		</method>

		<method name="isExpired" var="current,strip" return="bool">
		
			if  time.Now().Unix() > current.(int64) {
				if strip.(string) == "" {
				return true
				} else {
				return false
				} 
			}

			return false
		</method>

		<method name="getTemplate" return="core.Template" var="templates, name">
			 s := reflect.ValueOf(templates)
	       	 slice := make([]App,s.Len())
	          for i,_ := range slice {
	            v := s.Index(i).Interface().(core.Template) 

				if v.Name == name.(string) {
					return v
				}
	        }

			return core.Template{}
		</method>

		<method name="mConsole">
			

		</method>

		<method name="mPut">
			
			//response = "OK"
		</method>

		
		<method return="[]App" var="apps,name,app" name="updateApp">			
			 s := reflect.ValueOf(apps)
			 n := make([]App, s.Len())
	       	 slice := make([]App,s.Len())
	          for i,_ := range slice {
	            v := s.Index(i).Interface().(App) 

				if v.Name == name.(string) {
					n = append(n,app.(App))
				} else if v.Name != "" {
					n = append(n, v)
				}
	        }
			return n
		</method>
		<method return="App" var="apps,name" name="getApp">			
			 s := reflect.ValueOf(apps)
	       	 slice := make([]App,s.Len())
	          for i,_ := range slice {
	            v := s.Index(i).Interface().(App) 

				if v.Name == name.(string) {
					return v
				}
	        }

			return App{}
		</method>
	</methods>

		<templates>
	     	   <template name="Css" tmpl="css" struct="Dex" desc="Little Bootstrap override" />
	     	   <template name="JS" tmpl="js" struct="Dex" desc="JS End tag" />

	     	   <template name="FA" tmpl="ui/fa" struct="Dex" desc="JS End tag" />
	     	   <template name="PluginList" tmpl="ui/pluginlist" struct="" /> 

	     	   <!-- Dialogs -->
	     	   <template name="Login" tmpl="ui/login" struct="Dex" desc="Login Prompt" />
	     	   <template name="Modal" tmpl="ui/modal" struct="sModal" desc="Modal" />
	     	   <template name="xButton" tmpl="ui/sbutton" struct="sButton" desc="Button Gen" />
	     	   <template name="jButton" tmpl="ui/user/forms/jbutton" struct="sButton" desc="Button Gen" />

	     	   <template name="PUT" tmpl="ui/user/forms/aput" struct="Aput" desc="Button Gen" />

	     	   <template name="Group" tmpl="ui/user/forms/tab" struct="sTab" desc="Button Gen" />


	     	   <template name="Register" tmpl="ui/register" struct="Dex" desc="Register Prompt" />
	     	   <template name="Alert" tmpl="ui/alert" struct="Alertbs" desc="Amovible alert" />

	     	    <template name="StructEditor" tmpl="editor/structs" struct="vHuf" desc="Amovible alert" />

	     	     <template name="MethodEditor" tmpl="editor/methods" struct="vHuf" desc="Amovible alert" />
	     	      <template name="ObjectEditor" tmpl="editor/objects" struct="vHuf" desc="Amovible alert" />

	     	      <template name="EndpointEditor" tmpl="editor/endpoints" struct="TEditor"/>

	     	       <template name="TimerEditor" tmpl="editor/timers" struct="TEditor"/>

	     	   <template name="FSC" tmpl="ui/fsc" struct="FSCs" desc="Amovible alert" />
	     	   <template name="MV" tmpl="ui/mv" struct="FSCs" desc="Amovible alert" />
	     	   <template name="RM" tmpl="ui/user/rm" struct="FSCs" />


	     	   <template name="WebRootEdit" tmpl="ui/user/panel/webrootedit" struct="WebRootEdits" desc="Amovible alert" />

	     	   <template name="WebRootEdittwo" tmpl="ui/user/panel/webtwo" struct="WebRootEdits" desc="Amovible alert" />

	     	    <template name="uSettings" tmpl="editor/settings" struct="USettings" desc="Amovible alert" />


	     	   <!-- User forms -->
	     	  
	     	    <template name="Form" tmpl="ui/user/forms/form" struct="Forms" desc="" />
	     	   
	     	    <template name="SWAL" tmpl="ui/user/forms/swal" struct="sSWAL" desc="" />
	     	   	<!-- Panels for users ui/user/panel/ -->
	     	   	<template name="ROC" tmpl="ui/user/panel/roc" struct="sROC" desc="" />

	     	   	<template name="RPUT" tmpl="ui/user/forms/rput" struct="rPut" desc="" />

	     	   	 <template name="PackageEdit" tmpl="ui/user/panel/package" struct="sPackageEdit" desc="" />

	     	   	  <template name="Delete" tmpl="ui/user/panel/delete" struct="DForm" desc="" />

	     	   	  <template name="Welcome" tmpl="ui/welcome" struct="Dex" desc="" />

	     	   	  <template name="Stripe" tmpl="ui/stripe" struct="Dex" desc="" />

	     	   	  <template name="Debugger" tmpl="ui/debugger" struct="DebugObj" desc="" />

	     	   	
	     	   	  <template name="TemplateEdit" tmpl="ui/user/panel/templateEditor" struct="TemplateEdits" desc="" />
	     	   	  <template name="TemplateEditTwo" tmpl="ui/user/panel/tpetwo" struct="TemplateEdits" desc="" />

	     	   	<!-- Dex Elements (Generic) -->
	     	     <template name="Input" tmpl="ui/input" struct="Inputs" desc="Input Gen" />

	     	     <template name="DebuggerNode" tmpl="ui/debugnode" struct="DebugObj" desc="Input Gen" />
 
	     	     <template name="Button" tmpl="ui/button" struct="Dex" desc="Button Gen" />
				 <template name="Submit" tmpl="ui/submit" struct="Dex" desc="Submit Gen" />
				 <template name="Logo" tmpl="logo" struct="Dex" desc="Strukture logo" />
	    	 	 <template name="Navbar" tmpl="ui/navbar" struct="Dex" desc="Navbar" />
	    	 	 <template name="NavCustom" tmpl="ui/navbars" struct="Navbars" desc="Navbar Special..." />
	    	 	 <template name="NavMain" tmpl="ui/navmain" struct="Dex" desc="Home Page Menu" />
	    	 	 <template name="NavPKG" tmpl="ui/navpkg" struct="Dex" desc="Package Page Menu" />
	    	 	 <template name="CrashedPage" tmpl="ui/crashedpage" struct="Dex" desc="Package Page Menu" />
	    	 	 <template name="EndpointTesting" tmpl="ui/endpointtester" struct="Dex" />
	    	 	 <template name="KanBan" tmpl="ui/kanban" struct="Dex" />
	    	 	 <template name="Docker" tmpl="ui/docker" struct="Dex" />
	    	 	  <template name="SearchProject" tmpl="ui/search" struct="Dex" />
	    	 	 <template name="NavPromo" tmpl="ui/navpromo" struct="Dex" desc="Package Page Menu" />

          </templates>
		<endpoints>
				<!-- Package methods -->
				<end path="/api/dockerfile" type="POST" >
					imageName := r.FormValue("image")
					strat := r.FormValue("strat")
					port := r.FormValue("port")
					pkg := r.FormValue("pkg")

					dockerFilePath := filepath.Join(os.ExpandEnv("$GOPATH"), "src", pkg, "Dockerfile")

					
					var dockerfile string

					if strat == "Fast" {
						dockerfile = fmt.Sprintf(methods.DockerLarge, imageName, port, port)
					} else {
						dockerfile = fmt.Sprintf(methods.DockerSmall, imageName, port, port)
					}

					err := ioutil.WriteFile(dockerFilePath, []byte(dockerfile),0700)

					if err != nil {
						log.Println(err)
					}

					response = "OK"

				</end>

				<end path="/api/composer" type="POST" >
					methods.GenerateComposeFile(r)
					response = "OK"
				</end>


				<end path="/api/socket" type="star" >
					c, err := upgrader.Upgrade(w, r, nil)
					if err != nil {
						log.Print("upgrade:", err)
						return
					}
					defer c.Close()

					methods.AddConnection(c)
					for {
						_, message, err := c.ReadMessage()
						if err != nil {
							log.Println("read:", err)
							break
						}

						if len(message) != 0 {
							methods.Broadcast(message)
						}
						
					}

					
				</end>
				<end path="/api/pkg-bugs" type="GET">

						bugs := methods.GetLogs(r.FormValue("pkg"))
						sapp := net_getApp(methods.GetApps(), r.FormValue("pkg") )
						if len(bugs) == 0 || sapp.Passed {
							response = "{}"
						} else {
						response = mResponse(bugs[0])
						}
				</end>

				<end path="/api/kanban" type="GET">
					pkgName := r.FormValue("pkg")
					response = mResponse(methods.GetKanBan(pkgName))
				</end>

				<end path="/api/git" type="POST">
					pkgName := r.FormValue("pkg")
					cmd := r.FormValue("cmd")

				

					if cmd == "commit" {
						mess := r.FormValue("message")
						response = mResponse(methods.CommitGit(pkgName, mess))
					}

					if cmd == "push" {
						methods.PushGit(pkgName)
						response = mResponse(false)
					}

					
				</end>

				<end path="/api/kanban" type="POST">
					pkgName := r.FormValue("pkg")
					payload := r.FormValue("payload")

					methods.SaveKanBan(pkgName, payload)

					response = "OK"
				</end>

				<end path="/api/empty" type="GET" >
					
					methods.ClearLogs(r.FormValue("pkg"))
					response = net_bAlert(Alertbs{Type:"success",Text:"Your build logs are cleared." })
				</end>
				<end path="/api/search_project" type="f" >
					 path :=  filepath.Join(os.ExpandEnv("$GOPATH"), "src", r.FormValue("pkg"), r.FormValue("path") )
					 search := r.FormValue("text")

					 if r.FormValue("caseS") == "false" {
					 	search = "(?i)" + search
					 }

					 rg, err := regexp.Compile(search)

					 if err != nil {
					 	 response = fmt.Sprintf("%s", err)
					 	 callmet = true
					 	 return
					 }

					 results := []SearchResult{}
					 walkfunc := func(path string, info os.FileInfo, err error) error {
					    if err != nil {
					        return err
					    }

					    if info.IsDir() {
					    	return nil
					    }

					    if !strings.Contains( info.Name(), ".go") {
					    	return nil
					    }

					    fData, err := ioutil.ReadFile(path)

					    if err != nil {
					    	return err
					    }

					    sData := string(fData)
					    matches :=  rg.FindAllStringSubmatchIndex(sData, -1)

					    if len(matches) > 0 {
					    	ent := SearchResult{
					    		File : path,
					    		Snippet : sData,
					    		Matches : matches,
					    	}

					    	results = append(results, ent)

					    	//fmt.Println(path, info.Size())
					    }
			    
					    return nil
					}
					// file snippet matches

					if r.FormValue("top") == "true" {

						files, err := ioutil.ReadDir(path)

						if err != nil {
						    log.Fatal(err)
						    return
						}

						for _, f := range files {
						    if f.IsDir() {
						    	continue
						    }

						    if !strings.Contains( f.Name(), ".go") {
						    	continue
						    }

						    pathf := filepath.Join(path, f.Name())
						    fData, err := ioutil.ReadFile(pathf)

						    if err != nil {
						    	continue
						    }

						    sData := string(fData)
						    matches :=  rg.FindAllStringSubmatchIndex(sData, -1)

						    if len(matches) > 0 {
						    	ent := SearchResult{
						    		File : f.Name(),
						    		Snippet : sData,
						    		Matches : matches,
						    	}

						    	results = append(results, ent)

						    //	fmt.Println(f.Name())
						    }
						}

					} else {
						err = filepath.Walk(path, walkfunc)

						if err != nil {
						    fmt.Println(err)
						}
					}

					response = mResponse(results)
					callmet = true

				</end>
				<end path="/api/get" method="mGet" type="f" >
					me := SoftUser{Email:"Strukture user", Username:"Strukture user"}
			if r.FormValue("type") == "0" {
				
			    mpk := []bson.M{}


				apps := methods.GetApps()


for _, v := range apps {
				if v.Name != "" {
					
					appCo := []PkgItem{}
					Childtm := []PkgItem{}

					var folders []PkgItem
					var pkgpath = core.TrimSuffix(os.ExpandEnv("$GOPATH"), "/")+"/src/"+v.Name+"/"
					if Windows {
						pkgpath = strings.Replace(pkgpath,"/", "\\", -1)
					}

					if _, errr := os.Stat(pkgpath + "gos.gxml"); !os.IsNotExist(errr) {
					gos, _ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" + v.Name + "/gos.gxml")
					for _, b := range v.Groups {
						tmpls := []PkgItem{}

						for _, tm := range gos.Templates.Templates {
							if tm.Bundle == b {
								tmpls = append(tmpls, PkgItem{Type: "5", AppID: v.Name, Icon: "fa fa-page", DType: "5&tmpl=" + b + "/" + tm.Name, Text: tm.Name, ID: v.Name + "@pkg:" + b + "/" + tm.Name})
							}
						}

						Childtm = append(Childtm, PkgItem{AppID: v.Name, Text: b, Icon: "fa fa-square", CType: "4&bundle=" + b, DType: "4&bundle=" + b, RType: "4&bundle=" + b, Children: tmpls})

					}
					
					
					_ = filepath.Walk(pkgpath + "web", func(path string, file os.FileInfo, _ error) error {
						//fmt.Println(path)
						if file.IsDir() {
							lpathj := strings.Replace(path, pkgpath + "web", "", -1)


							loca := PkgItem{AppID: v.Name, Text: lpathj, Icon: "fa fa-folder", Children: []PkgItem{}}

							loca.CType = "5&path=" + lpathj
							loca.DType = "6&isDir=Yes&path=" + lpathj

							loca.MType = "6&path=" + lpathj

							files, _ := ioutil.ReadDir(path)

							for _, f := range files {
								if !f.IsDir() && !strings.Contains(f.Name(), "go-breakpoints") {
									var mjk string


									mjk =strings.Replace(path, pkgpath +"web" , "",-1) + "/" + f.Name() 
									if Windows {
										mjk = strings.Replace(mjk, "/", "\\", -1)
									}

									loca.Children = append(loca.Children, PkgItem{AppID: v.Name, Text: f.Name(), Icon: "fa fa-page", Type: "6", ID: v.Name + "@pkg:" + mjk, MType: "6&path=" + mjk, DType: "6&isDir=No&path=" + mjk})

								}
							}

							folders = append(folders, loca)

						}
						//fmt.Println(file,path,file.Name,file.IsDir())
						//   var loca PkgItem = PkgItem{AppID:v.Name,Text: file.Name(),Icon: "fa fa-folder"}

						return nil
					})

					

						appCo = append(appCo, PkgItem{AppID: v.Name, Text: "Template bundles", Icon: "fa fa-pencil-square", CType: "3", Children: Childtm})
						appCo = append(appCo, PkgItem{AppID:v.Name,Text: "Web Resources",CType:"5&path=/",Children:folders,Icon: "fa fa-folder"} )
						
					
						//appCo = append(appCo, PkgItem{AppID:v.Name,Type:"18",Text: "Testing",Icon: "fa fa-flask"} )
						appCo = append(appCo, PkgItem{AppID:v.Name,Type:"8",Text: "Structs",Icon: "fa fa-share-alt"} )
						//appCo = append(appCo, PkgItem{AppID:v.Name,Type:"9",Text: "Interface funcs",Icon: "fa fa-share-alt-square"} )
						appCo = append(appCo, PkgItem{Type:"10",AppID:v.Name,Text: "Template pipelines",Icon: "fa fa-exchange"} )

						appCo = append(appCo, PkgItem{AppID:v.Name,Type:"11",Text: "Web services",Icon: "fa fa-circle-o-notch"} )
					}

					

					

					var goFiles,ymlFiles []PkgItem

					_ = filepath.Walk(pkgpath, func(path string, file os.FileInfo, _ error) error {
						//fmt.Println(path)
						if file.IsDir() {
							lpathj := strings.Replace(path, pkgpath, "", -1)

							loca  := PkgItem{AppID: v.Name, Text: lpathj, Icon: "fa fa-circle", Children: []PkgItem{}}
							hasgo := false
							files, _ := ioutil.ReadDir(path)
							for _, f := range files {
								if !f.IsDir() && strings.Contains(f.Name(), ".go") && !strings.Contains(f.Name(), ".go-breakpoints") {

									var mjk string
									mjk = strings.Replace(path, pkgpath, "", -1) + "/" + f.Name()
									if Windows {
										mjk = strings.Replace(mjk, "/", "\\", -1)
									}
									hasgo = true
									loca.Children = append(loca.Children, PkgItem{AppID: v.Name, Text: f.Name(), Icon: "fa fa-code", Type: "60", ID: v.Name + "@pkg:" + mjk, MType: "60&path=" + mjk, DType: "60&isDir=No&path=" + mjk})

								}
							}

							loca.CType = "50&path=" + lpathj
							loca.DType = "60&isDir=Yes&path=" + lpathj

							loca.MType = "60&path=" + lpathj

							if hasgo {
								goFiles = append(goFiles, loca)
							}

						}
						//fmt.Println(file,path,file.Name,file.IsDir())
						//   var loca PkgItem = PkgItem{AppID:v.Name,Text: file.Name(),Icon: "fa fa-folder"}

						return nil
					})

					_ = filepath.Walk(pkgpath, func(path string, file os.FileInfo, _ error) error {
						//fmt.Println(path)
						if file.IsDir() {
							lpathj := strings.Replace(path, pkgpath, "", -1)

							loca  := PkgItem{AppID: v.Name, Text: lpathj, Icon: "fa fa-folder", Children: []PkgItem{}}
							hasyml := false
							files, _ := ioutil.ReadDir(path)
							for _, f := range files {
								if !f.IsDir() && strings.Contains(f.Name(), ".yml") {

									var mjk string
									mjk = strings.Replace(path, pkgpath, "", -1) + "/" + f.Name()
									if Windows {
										mjk = strings.Replace(mjk, "/", "\\", -1)
									}
									hasyml = true
									loca.Children = append(loca.Children, PkgItem{AppID: v.Name, Text: f.Name(), Icon: "fa fa-magic", Type: "61", ID: v.Name + "@pkg:" + mjk, MType: "60&path=" + mjk, DType: "60&isDir=No&path=" + mjk})

								}
							}

							loca.CType = "51&path=" + lpathj
							loca.DType = "60&isDir=Yes&path=" + lpathj

							loca.MType = "60&path=" + lpathj

							if hasyml {
								ymlFiles = append(ymlFiles, loca)
							}

						}
						
						return nil
					})

					appCo = append(appCo, PkgItem{AppID:v.Name,Text: "Go SRC",CType:"50&path=/",Children:goFiles,Icon: "fa fa-cube"} )


					appCo = append(appCo, PkgItem{AppID:v.Name,Type:"300",Text: "KanBan board",Icon: "fa fa-briefcase"} )

					if v.Type != "faas" {
						
						appCo = append(appCo, PkgItem{AppID:v.Name,Type:"16",Text: "Logs",Icon: "fa fa-list"} )
						appCo = append(appCo, PkgItem{AppID:v.Name,Type:"7",Text: "Build center",Icon: "fa fa-server"} )
						appCo = append(appCo, PkgItem{AppID:v.Name,Type:"5500",Text: "Docker",Icon: "fa fa-cloud-upload"} )

					} else {
						var functions []PkgItem

						for _,fn := range v.Groups {
							ref := PkgItem{AppID: v.Name, Text: fn, Icon: "fa fa-cube", Type: "62", ID: v.Name + "@pkg:" + fn, DType: "62&path=" + fn }
							functions = append(functions, ref)
						}

						appCo = append(appCo, PkgItem{AppID:v.Name,CType:"52", Children : functions ,Text: "Functions",Icon: "fa fa-cubes"} )
					}


					appCo = append(appCo, PkgItem{AppID:v.Name,CType:"51&path=/", Children : ymlFiles ,Text: "YAML files",Icon: "fa fa-folder"} )

					
				
					//appCo = append(appCo, PkgItem{AppID:v.Name,Type:"12",Text: "Timers",Icon: "fa fa-clock-o"} )




						rootel := bson.M{"dtype" : "3","text": v.Name,"type":"1","id" : v.Name, "children" : appCo,"appid":v.Name,"btype" : "on"  }

						if v.Type == "webapp" {
							rootel["icon"] = "fa fa-globe"
						} else if v.Type == "app" {
							rootel["icon"] = "fa fa-folder"
							rootel["project"] = true
						} else if v.Type == "faas" {
							rootel["icon"] = "fa fa-rocket"
							rootel["project"] = true
							rootel["btype"] = nil
						} else {
							rootel["icon"] = "fa fa-gift"
						}

						//append to children
						//add server in
	         			mpk = append(mpk, rootel)
         			}
				}

				response = mResponse(mpk)
			} else if r.FormValue("type") == "1" {

				//get package
				sapp := net_getApp(methods.GetApps(), r.FormValue("id"))
				prefix := "/api/put?type=0&id=" + sapp.Name 	


				//set params democss,port,key,name,type
				editor := sPackageEdit{Type:sapp.Type,TName: sapp.Name }
				pkgpath := os.ExpandEnv("$GOPATH") + "/src/" +  sapp.Name + "/gos.gxml"

				if _, err := os.Stat(pkgpath); !os.IsNotExist(err) {

					gos,_ := core.LoadGos(pkgpath)
					editor.IType = Aput{Link:prefix, Param: "app",Value: gos.Type }

					editor.Port =  Aput{ Link:prefix ,Param: "port",Value: gos.Port }
					editor.Key =  Aput{ Link:prefix ,Param: "key",Value: gos.Key }
					editor.Domain =  Aput{ Link:prefix ,Param: "domain",Value: gos.Domain }
					editor.Erpage =  Aput{ Link:prefix ,Param: "erpage",Value: gos.ErrorPage }

					editor.Ffpage =  Aput{ Link:prefix ,Param: "fpage",Value: gos.NPage }
					editor.Name =  Aput{ Link:prefix ,Param: "Name",Value: sapp.Name }
					editor.Package =  Aput{Link:"/api/put?type=16&pkg=" + sapp.Name,Param:"npk",Value:gos.Package}
					
					editor.Mainf = gos.Main
					editor.Shutdown =  gos.Shutdown
					editor.Initf = gos.Init_Func
					editor.Sessionf = gos.Session 
					
					varf := []Inputs{}
					varf = append(varf, Inputs{Name: "is", Type:"text",Text: "Variable type"})
					varf = append(varf, Inputs{Name: "name", Type:"text",Text: "Variable name"})
					editor.CreateVar = types.RPut{Count:"4",Link:"/api/create?type=0&pkg=" + sapp.Name, Inputs : varf,ListLink: "/api/get?type=2&pkg=" + sapp.Name }

				   varf = []Inputs{}
					varf = append(varf, Inputs{Name: "src", Type:"text",Text: "Package path"})
					
					editor.CreateImport = types.RPut{Count:"6",Link:"/api/create?type=1&pkg=" + sapp.Name, Inputs : varf,ListLink: "/api/get?type=3&pkg=" + sapp.Name  }	
					varf = []Inputs{}
					varf = append(varf, Inputs{Name:"src", Type:"text",Text:"Path to css lib"})
					editor.Css = types.RPut{Count:"6", Link:"/api/create?type=2&pkg=" + sapp.Name, Inputs: varf,ListLink: "/api/get?type=4&pkg=" + sapp.Name  }
					response = net_bPackageEdit(editor)
				} else {
					response = ""
				}

			


			} else if r.FormValue("type") == "2" {

		
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				for _,v := range gos.Variables {
						varf := []Inputs{}
						varf = append(varf, Inputs{Name: "is", Type:"text",Text: "Variable type",Value:v.Type})
						varf = append(varf, Inputs{Name: "name", Type:"text",Text: "Variable name",Value: v.Name})
						response = response + net_bRPUT(types.RPut{DLink: "/api/delete?type=0&pkg=" + r.FormValue("pkg") + "&id=" + v.Name,Count:"4",Link:"/api/act?type=1&pkg=" + r.FormValue("pkg") + "&id=" + v.Name,Inputs:varf })
				}

				
			}  else if r.FormValue("type") == "3" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				for _,v := range gos.RootImports {
						varf := []Inputs{}
						varf = append(varf, Inputs{Name: "src", Type:"text",Text: "Package path",Value:v.Src})
	
						response = response + net_bRPUT(types.RPut{DLink: "/api/delete?type=1&pkg=" + r.FormValue("pkg") + "&id=" + v.Src,Count:"6",Link:"/api/act?type=2&pkg=" + r.FormValue("pkg") + "&id=" + v.Src ,Inputs:varf })
				}

			}  else if r.FormValue("type") == "4" {
				sapp := net_getApp(methods.GetApps(), r.FormValue("pkg"))

				for _,v := range sapp.Css {					

					    varf := []Inputs{}
						varf = append(varf, Inputs{Name: "src", Type:"text",Text: "Path to css lib",Value:v})
	
						response = response + net_bRPUT(types.RPut{DLink: "/api/delete?type=2&pkg=" + r.FormValue("pkg") + "&id=" + v,Count:"6",Link:"/api/act?type=3&pkg=" + r.FormValue("pkg") + "&id=" + v ,Inputs:varf })
				}

			} else if r.FormValue("type") == "5" {
				id := strings.Split(r.FormValue("id"), "@pkg:")
				data,_ := ioutil.ReadFile(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/tmpl/" + id[1] + ".tmpl" )
				
				data = []byte(html.EscapeString(string(data)) )				
				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/gos.gxml")

				 template := net_getTemplate(gos.Templates.Templates, id[1])

				varf := []Inputs{}
				varf = append(varf, Inputs{Type:"text", Value:template.Struct ,Name:"struct",Text:"Interface to use with template" })

				response = net_bTemplateEdit(TemplateEdits{SavesTo:"tmpl/" + id[1] + ".tmpl",ID:net_RandTen(),PKG: r.FormValue("space"),Mime:"html", File :  data,Settings: types.RPut{Link:"/api/put?type=2&id=" + id[1] + "&pkg=" + r.FormValue("space"),Inputs:varf, Count:"6"   } })
			} else if r.FormValue("type") == "6" {
				id := strings.Split(r.FormValue("id"), "@pkg:")
				filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/web" + id[1]
				var ftype string
				if strings.Contains(filep, ".css"){
					ftype = "css"
				} else if strings.Contains(filep,".js"){
					ftype = "javascript"
				} else if strings.Contains(filep,".html") {
					ftype = "html" 
				} else if strings.Contains(filep,".tmpl") {
					ftype = "html"
					//add auto complete linking
				}
				data,_ := ioutil.ReadFile(filep)
				data =  []byte(html.EscapeString(string(data)))
				response = net_bWebRootEdit(WebRootEdits{SavesTo:id[1],Type:ftype,File:data,ID:net_RandTen(),PKG: r.FormValue("space") })

			} else if r.FormValue("type") == "60" {
				id := strings.Split(r.FormValue("id"), "@pkg:")
				filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/" + id[1]
					
				filep = strings.Replace(filep, "//", "/", -1)

				if Windows {
					filep = strings.Replace(filep, "/", "\\", -1)
				}

				data,_ := ioutil.ReadFile(filep)
				data =  []byte(html.EscapeString(string(data)))

				breakPoints,err := ioutil.ReadFile(filep + "-breakpoints")

				editor := WebRootEdits{SavesTo:id[1],Type:"golang",File:data,ID:net_RandTen(),PKG: r.FormValue("space") }

				if err == nil {
					editor.BreakPoints = breakPoints
				} 

				//BreakPoints

				response = net_bWebRootEdittwo(editor)

			} else if r.FormValue("type") == "61" {
				id := strings.Split(r.FormValue("id"), "@pkg:")
				filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/" + id[1]
					
				filep = strings.Replace(filep, "//", "/", -1)

				if Windows {
					filep = strings.Replace(filep, "/", "\\", -1)
				}

				data,_ := ioutil.ReadFile(filep)
				data =  []byte(html.EscapeString(string(data)))
				response = net_bWebRootEdittwo(WebRootEdits{SavesTo:id[1],Type:"yaml",File:data,ID:net_RandTen(),PKG: r.FormValue("space") })

			} else if r.FormValue("type") == "62" {
				id := strings.Split(r.FormValue("id"), "@pkg:")
				function :=  id[1] + "/handler.go"

				filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/" + function
					
				filep = strings.Replace(filep, "//", "/", -1)

				if Windows {
					filep = strings.Replace(filep, "/", "\\", -1)
				}

				data,_ := ioutil.ReadFile(filep)
				data =  []byte(html.EscapeString(string(data)))
				response = net_bWebRootEdittwo(WebRootEdits{SavesTo: function, Faas : true, Type:"golang",File:data,ID:net_RandTen(),PKG: r.FormValue("space"), PreviewLink : id[1] })

			}  else if r.FormValue("type") == "7" {
				sapp := net_getApp(methods.GetApps(), r.FormValue("space"))
				response = net_bROC(sROC{Name:r.FormValue("space"),Build: sapp.Passed,Time:sapp.LatestBuild,Pid : sapp.Pid })
			} else if r.FormValue("type") == "8" {

				 filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/structs.dsl"
					
				 b,e := ioutil.ReadFile(filep)
				 if e != nil {
				 	
				 	b = []byte("<gos> \n \n </gos> ")
				 }

				 data := html.EscapeString(string(b[:len(b)]))

				 b = []byte(data)
				
				 response = net_bStructEditor(vHuf{Edata:b,PKG: r.FormValue("space") })

			} else if r.FormValue("type") == "9" {

				 filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/objects.dsl"
					
				 b,e := ioutil.ReadFile(filep)
				  if e != nil {
				 	
				 	b = []byte("<gos> \n \n </gos> ")
				 }

				 data := html.EscapeString(string(b[:len(b)]))

				 b = []byte(data)

				 response = net_bObjectEditor(vHuf{Edata:b,PKG: r.FormValue("space") })

			} else if r.FormValue("type") == "10" {

				 filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/methods.dsl"
					
				 b,e := ioutil.ReadFile(filep)
				 if e != nil {
				 	
				 	b = []byte("<gos> \n \n </gos> ")
				 }

				 data := html.EscapeString(string(b[:len(b)]))

				 b = []byte(data)

				 response = net_bMethodEditor(vHuf{Edata:b,PKG: r.FormValue("space") })

			} else if r.FormValue("type") == "11" {

				varf := []Inputs{}
				varf = append(varf,Inputs{Name:"path",Type:"text", Text:"Endpoint path"})
				kput := types.RPut{ListLink:"/api/get?type=13&space=" + r.FormValue("space"),Inputs:varf,Count:"6",Link:"/api/put?type=7&space=" + r.FormValue("space")}
				response = net_bEndpointEditor(TEditor{CreateForm:kput,PKG:r.FormValue("space")})

			} else if r.FormValue("type") == "12" {
				varf := []Inputs{}
				varf = append(varf,Inputs{Name:"name",Type:"text", Text:"Timer name"})
				kput := types.RPut{ListLink:"/api/get?type=14&space=" + r.FormValue("space"),Inputs:varf,Count:"6",Link:"/api/put?type=8&space=" + r.FormValue("space")}
				response = net_bTimerEditor(TEditor{CreateForm:kput,PKG:r.FormValue("space")})
			} else if r.FormValue("type") == "13" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/gos.gxml")

				for _,v := range gos.Endpoints.Endpoints {

					varf := []Inputs{}
					varf = append(varf, Inputs{Name:"path", Type:"text",Text:"Endpoint path",Value:v.Path})
					//varf = append(varf, Inputs{Name:"method", Type:"text",Text:"Endpoint method",Value:v.Method})
					varf = append(varf, Inputs{Name:"typ", Type:"text",Text:"Request type : GET,POST,PUT,DELETE,f,star...",Value:v.Type})

					response = response + net_bRPUT(types.RPut{DLink:"/api/delete?type=7&pkg=" + r.FormValue("space") + "&path=" + v.Id ,Link:"/api/put?type=9&id=" + v.Id + "&pkg=" + r.FormValue("space")  ,Count:"12",Inputs:varf})  + methods.Addjsstr
					

				}				

			} else if r.FormValue("type") == "13r" {

			gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				for _,v := range gos.Endpoints.Endpoints {
				
				if v.Id == r.FormValue("id")  {
					id := net_RandTen()
					response = net_bTemplateEditTwo(TemplateEdits{SavesTo:"gosforceasapi/" + r.FormValue("id") + "++()/"  ,ID:id,PKG: r.FormValue("pkg"),Mime:"golang", File :  []byte(v.Method) }) 
					}
				}

			} else if r.FormValue("type") == "14" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/gos.gxml")

				for _,v := range gos.Timers.Timers {

					varf := []Inputs{}
					varf = append(varf, Inputs{Name:"name", Type:"text",Text:"Timer name",Value:v.Name})
					varf = append(varf, Inputs{Name:"interval", Type:"number",Text:"Interval",Value:v.Interval})
					varf = append(varf, Inputs{Name:"unit", Type:"text",Text:"Timer refresh unit",Value:v.Unit})
					varf = append(varf, Inputs{Name:"method", Type:"text",Text:"Method to execute",Value:v.Method})
					response = response + net_bRPUT(types.RPut{DLink:"/api/delete?type=8&pkg=" + r.FormValue("space") + "&name=" + v.Name ,Link:"/api/put?type=10&id=" + v.Name + "&pkg=" + r.FormValue("space"),Count:"2",Inputs:varf}) 
					
				}	

			}  else if r.FormValue("type") == "15" {

					tempx := net_buSettings(USettings{StripeID:me.StripeID,LastPaid:"Date",Email:me.Email})
					response = net_bModal(sModal{Title:"Account settings",Body:tempx,Color:"orange"})
			}  else if r.FormValue("type") == "16" { 

				response = netbDebugger(DebugObj{PKG:r.FormValue("space"),Username: "" })
			} else if r.FormValue("type") == "17" {

				var tDebugNode types.DebugObj

				if r.FormValue("id") == "Server" {
					tDebugNode = DebugObj{Time:"Server",Bugs:[]DebugNode{}}
					gp := os.ExpandEnv("$GOPATH")
		    		os.Chdir( gp + "/src/" +  r.FormValue("space") )
		    		//main.log
		    		rlog, err := ioutil.ReadFile("main.log")
		    		if err != nil {
		    			tDebugNode.RawLog = err.Error()
		    		} else {
		    			tDebugNode.RawLog = string(rlog)
		    		}
				} else {
 				logs := methods.GetLogs(r.FormValue("space"))
			
				for _, logg := range logs {
					if logg.Time == r.FormValue("id") {
						tDebugNode = logg
					}
				} 
				}
				
				
				
				response = net_bDebuggerNode(tDebugNode)
				
			} else if r.FormValue("type") == "18" {

				response = net_bEndpointTesting(Dex{Misc:r.FormValue("space")})

			} else if r.FormValue("type") == "300" {

				response = net_bKanBan(Dex{Misc:r.FormValue("space")})

			} else if r.FormValue("type") == "5500" {
				response = net_bDocker(Dex{Misc:r.FormValue("space")})
			} else if r.FormValue("type") == "5505" {
				response = net_bSearchProject(Dex{
					Link : r.FormValue("pkg"),
					Misc: r.FormValue("path"),
				})
			}

			callmet = true
				</end>

				<end path="/api/tester/" type="POST" >
					gp := os.ExpandEnv("$GOPATH")
		    		os.Chdir( gp + "/src/" +  r.FormValue("pkg") )
					logfull , _ := core.RunCmdSmart("gos " + r.FormValue("mode") + " " + r.FormValue("c"))
					response = html.EscapeString(logfull)
				</end>
			
				<end path="/api/create" method="mCreate" type="POST" >
				//me := &SoftUser{Email:"Strukture user", Username:"Strukture user"}
			 
			if r.FormValue("type") == "0" {
				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				 gos.Add("var", r.FormValue("is"), r.FormValue("name")) 
			    // fmt.Println(gos)
				
						
				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

			} else if r.FormValue("type") == "1" {
				//import
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				 gos.Add("import", "", r.FormValue("src")) 
			     //fmt.Println(gos)
			
						
				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
			} else if r.FormValue("type") == "2" {
				//css
				apps := methods.GetApps()
				app := net_getApp(methods.GetApps(), r.FormValue("pkg"))
				app.Css = append(app.Css, r.FormValue("src"))
				apps = net_updateApp(methods.GetApps(), r.FormValue("pkg"), app)
				methods.SaveApps(apps)
				//Users.Update(bson.M{"uid":me.UID}, me)
			} else if r.FormValue("type") == "3" {
				varf := []Inputs{}
				varf = append(varf, Inputs{Name:"name",Type:"text",Text:"Bundle name"})

				response = net_bForm(Forms{Link:"/api/act?type=4&pkg=" + r.FormValue("pkg"),CTA:"Create Bundle",Class:"warning", Inputs:varf})

			} else if r.FormValue("type") == "4" {
				varf := []Inputs{}
				varf = append(varf, Inputs{Name:"name",Type:"text",Text:"Template name"})

				response = net_bForm(Forms{Link:"/api/act?type=5&pkg=" + r.FormValue("pkg") + "&bundle=" + r.FormValue("bundle"),CTA:"Create Template file",Class:"warning", Inputs:varf})

			} else if r.FormValue("type") == "5" {
			 	//prefix pkg 
			 	varf := []Inputs{}
				varf = append(varf, Inputs{Type:"text",Name:"path", Text:"Path"})
				varf = append(varf, Inputs{Type:"hidden",Name:"basesix" })
				varf = append(varf, Inputs{Type:"hidden",Name:"fmode",Value:"touch" })

				response = net_bFSC(FSCs{Path:r.FormValue("path"), Form: Forms{Link:"/api/act?type=6&pkg=" + r.FormValue("pkg") + "&prefix=" + r.FormValue("path"), Inputs:varf,CTA:"Create",Class:"warning" } })
			} else if r.FormValue("type") == "50" {
			 	//prefix pkg 
			 	varf := []Inputs{}
				varf = append(varf, Inputs{Type:"text",Name:"path", Text:"Path"})
				varf = append(varf, Inputs{Type:"hidden",Name:"basesix" })
				varf = append(varf, Inputs{Type:"hidden",Name:"fmode",Value:"touch" })

				response = net_bFSC(FSCs{Path:r.FormValue("path"), Form: Forms{Link:"/api/act?type=60&pkg=" + r.FormValue("pkg") + "&prefix=" + r.FormValue("path"), Inputs:varf,CTA:"Create",Class:"warning" } })
			} else if r.FormValue("type") == "51" {
			 	//prefix pkg 
			 	varf := []Inputs{}
				varf = append(varf, Inputs{Type:"text",Name:"path", Text:"Path"})
				varf = append(varf, Inputs{Type:"hidden",Name:"basesix" })
				varf = append(varf, Inputs{Type:"hidden",Name:"fmode",Value:"touch" })

				response = net_bFSC(FSCs{Path:r.FormValue("path"), Form: Forms{Link:"/api/act?type=61&pkg=" + r.FormValue("pkg") + "&prefix=" + r.FormValue("path"), Inputs:varf,CTA:"Add YAML file",Class:"warning" } })
			} else if r.FormValue("type") == "52" {
			 	//prefix pkg 
			 	varf := []Inputs{}
				varf = append(varf, Inputs{Type:"text",Name:"name", Text:"Function name."})
				response = net_bFSC(FSCs{Path:r.FormValue("path"), Hide : true, Form: Forms{Link:"/api/act?type=62&pkg=" + r.FormValue("pkg") + "&prefix=" + r.FormValue("path"), Inputs:varf,CTA:"Add function",Class:"success" } })
				

			} else if r.FormValue("type") == "6" {
				varf := []Inputs{}
				varf = append(varf, Inputs{Type:"text",Name:"path",Misc:"required", Text:"New path"})

				response = net_bMV(FSCs{Path:r.FormValue("path"), Form: Forms{Link:"/api/act?type=7&pkg=" + r.FormValue("pkg") + "&prefix=" + r.FormValue("path"), Inputs:varf,CTA:"Move",Class:"warning" } })	
			} else if r.FormValue("type") == "60" {
				varf := []Inputs{}
				varf = append(varf, Inputs{Type:"text",Name:"path",Misc:"required", Text:"New path"})

				response = net_bMV(FSCs{Path:r.FormValue("path"), Form: Forms{Link:"/api/act?type=70&pkg=" + r.FormValue("pkg") + "&folder=" + "&prefix=" + r.FormValue("path"), Inputs:varf,CTA:"Move",Class:"warning" } })	
			}
				</end>

				<end path="/api/delete" method="mDelete" type="POST" >
				
			if r.FormValue("type") == "0" {

				//type pkg id
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				gos.Delete("var", r.FormValue("id"))

					gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

			} else if r.FormValue("type") == "101" {

				//type pkg id
				plugins := methods.GetPlugins()
				newset := []string{}

				for _,v := range plugins {
					if v != r.FormValue("pkg") {
						newset = append(newset, v)
					}
				}

				plugins = newset

				methods.SavePlugins(plugins)

			} else if r.FormValue("type") == "1" {
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				gos.Delete("import", r.FormValue("id"))

					gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
			} else if r.FormValue("type") == "2" {
				apps := methods.GetApps()
				app := net_getApp(apps, r.FormValue("pkg"))
				temp := []string{}
				for _,v := range app.Css {
					if v != r.FormValue("id") {
						temp = append(temp, v)
					}
				}
				app.Css = temp
				apps = net_updateApp(apps, r.FormValue("pkg"), app)
				methods.SaveApps(apps)
				//Users.Update(bson.M{"uid":me.UID}, me)
			} else if r.FormValue("type") == "3" {
				//pkg
				if r.FormValue("conf") != "do" {
					response = net_bDelete(DForm{Text:"Are you sure you want to delete the package " + r.FormValue("pkg") ,Link:"type=3&pkg=" + r.FormValue("pkg")})


				} else {
					//delete
					os.RemoveAll( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg"))

					newapps := []App{}
					apps := methods.GetApps()
					for _,v := range apps {

						if v.Name != r.FormValue("pkg") {
							newapps = append(newapps, v)
						}

					}
					methods.SaveApps(newapps)

					response = net_bAlert(Alertbs{Type:"success",Text:"Success package " + r.FormValue("pkg") + " was removed. Please reload page to close all linked resources.",Redirect: "javascript:updateTree()"})
				}

			} else if r.FormValue("type") == "4" {
				//pkg
				if r.FormValue("conf") != "do" {
					response = net_bDelete(DForm{Text:"Are you sure you want to delete the bundle " + r.FormValue("bundle") + " and all of its sub templates" ,Link:"type=4&bundle=" +  r.FormValue("bundle") + "&pkg=" + r.FormValue("pkg")})
				} else {
					//delete bundle
					apps := methods.GetApps()
					sapp := net_getApp(apps, r.FormValue("pkg"))

					replac := []string{}

					for _,v := range sapp.Groups {

							if r.FormValue("bundle") != v {
								replac = append(replac, v)
							}

					}
					
					sapp.Groups = replac
					apps = net_updateApp(apps, sapp.Name,	sapp)
					methods.SaveApps(apps)
					gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
					os.RemoveAll(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/tmpl/" + r.FormValue("bundle") )
					gos.Delete("bundle", r.FormValue("bundle"))

					gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")


					response = net_bAlert(Alertbs{Type:"success",Text:"Success bundle was removed!",Redirect: "javascript:updateTree()"})
				}

			} else if r.FormValue("type") == "5" {
				//pkg
				if r.FormValue("conf") != "do" {
					response = net_bDelete(DForm{Text:"Are you sure you want to delete the template " + r.FormValue("tmpl") ,Link:"type=5&tmpl=" + r.FormValue("tmpl") + "&pkg=" + r.FormValue("pkg")})
				} else {
					//delete

					os.RemoveAll( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/tmpl/" + r.FormValue("tmpl") + ".tmpl")

					gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
					parsedStr := strings.Split(r.FormValue("tmpl"),"/")
					gos.Delete("template", parsedStr[len(parsedStr) - 1] )

					gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")


					response = net_bAlert(Alertbs{Type:"success",Text:"Success template " + r.FormValue("tmpl") + " was removed!",Redirect: "javascript:updateTree()"})
				}

			} else if r.FormValue("type") == "6" {
				//pkg
				if r.FormValue("conf") != "do" {
					response = net_bDelete(DForm{Text:"Are you sure you want to delete the web resource at " + r.FormValue("path") ,Link:"type=6&conf=do&path=" + r.FormValue("path") + "&pkg=" + r.FormValue("pkg")  })


				} else {
					//delete
					if r.FormValue("isDir") == "Yes" {
						os.RemoveAll( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web" + r.FormValue("path"))
					} else {
						os.RemoveAll(  os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web" + r.FormValue("path"))
					}
					response = net_bAlert(Alertbs{Type:"success",Text:"Success resource at " + r.FormValue("path") + " was removed!",Redirect: "javascript:updateTree()"})
				}

			}  else if r.FormValue("type") == "60" {
				//pkg
				if r.FormValue("conf") != "do" {
					response = net_bDelete(DForm{Text:"Are you sure you want to delete the resource at " + r.FormValue("path") ,Link:"type=60&conf=do&path=" + r.FormValue("path") + "&pkg=" + r.FormValue("pkg")  })


				} else {
					//delete
					if r.FormValue("isDir") == "Yes" {
						os.RemoveAll( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/" +  r.FormValue("path"))
					} else {
						os.RemoveAll(  os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/" +  r.FormValue("path"))
					}
					response = net_bAlert(Alertbs{Type:"success",Text:"Success resource at " + r.FormValue("path") + " removed!",Redirect: "javascript:updateTree()"})
				}

			}  else if r.FormValue("type") == "62" {
				//pkg
				if r.FormValue("conf") != "do" {
					response = net_bDelete(DForm{Text:"Are you sure you want to delete the function " + r.FormValue("path") ,Link:"type=62&conf=do&path=" + r.FormValue("path") + "&pkg=" + r.FormValue("pkg")  })

				} else {
					//delete
					apps := methods.GetApps()
					app := net_getApp(methods.GetApps(), r.FormValue("pkg"))
					
					newGroups := []string{}

					for _, group := range app.Groups {
						if group != r.FormValue("path") {
							newGroups  = append(newGroups, group)
						}
					}

					app.Groups = newGroups

					apps = net_updateApp(methods.GetApps(), r.FormValue("pkg"), app)
					methods.SaveApps(apps)

					os.RemoveAll( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/" +  r.FormValue("path") )
					os.RemoveAll(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/" + r.FormValue("path") + ".yml")
					
					response = net_bAlert(Alertbs{Type:"success",Text:"Success, function " + r.FormValue("path") + " removed!",Redirect: "javascript:updateTree()"})
				}

			} else if r.FormValue("type") == "7" {
				//type pkg path name
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				gos.DeleteEnd( r.FormValue("path") )

				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

			} else if r.FormValue("type") == "8" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				gos.Delete("timer", r.FormValue("name"))

				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
			} else if r.FormValue("type") == "9" {
				

			}
				</end>
				<end path="/api/rename" method="mRename" type="POST" >

				</end>
				<end path="/api/new" method="mNew" type="POST" >
			
			if r.FormValue("type") == "0" {
	     		inputs := []Inputs{}
	     		inputs = append(inputs, Inputs{Type:"text",Name:"name",Misc: "required",Text:"Package Name"})
	     		inputs = append(inputs, Inputs{Type:"hidden", Name: "type" ,Value: "0"})
	     		inputs = append(inputs, Inputs{Type:"select", Misc : "Project type" , Name: "usegos" ,Value: "Scratch", Options : []string{"Scratch", "Existing package"} })
	     		
	     		response = net_bModal(sModal{Body: "",Title: "Add Package",Color: "#ededed",Form:Forms{Link:"/api/act",CTA:"Add Package",Class:"warning btn-block",Buttons:[]SButton{}, Inputs:inputs }})
				
			} else if r.FormValue("type") == "100" {
	     		inputs := []Inputs{}
	     		inputs = append(inputs, Inputs{Type:"text",Name:"name",Misc: "required",Text:"Plugin install path"})
	     		inputs = append(inputs, Inputs{Type:"hidden", Name: "type" ,Value: "100"})
	     		response = net_bModal(sModal{Body: "",Title: "PLUGINS",Color: "#ededed",Form:Forms{Link:"/api/act",CTA:"ADD",Class:"warning btn-block",Buttons:[]SButton{}, Inputs:inputs }})
			} else if r.FormValue("type") == "101" {
	     		
	     		response = bPluginList(gosweb.NoStruct{})
			}
				</end>
				<end path="/api/act" method="mAct" type="POST" >
			
				
			if r.FormValue("type") == "0" {
				apps := methods.GetApps()
				app := App{Type:"webapp",Name: r.FormValue("name")}
				useGos := r.FormValue("usegos")

				var err error
			   

			    dir := os.ExpandEnv("$GOPATH") + "/src/" + r.FormValue("name")

				if _, err := os.Stat(dir); os.IsNotExist(err) {
					if strings.Contains(useGos, "Scratch")   {
						app.Type = "app"

						fullDir := filepath.Join(os.ExpandEnv("$GOPATH"), "src", app.Name )
						err = os.MkdirAll(fullDir, 0700 )
						

						if err != nil {
							response = net_bAlert(Alertbs{Type:"danger",Text:"Error creating package " + r.FormValue("name") + ":" + err.Error(),Redirect: "javascript:console.log('error!')"})
						} else {

							os.Chdir(fullDir)
							core.RunCmdSmart("go mod init")
						}

					} else if strings.Contains(useGos, "faas") {

						app.Type = "faas"
						
						app.Groups = []string{}

						err = os.MkdirAll(filepath.Join(os.ExpandEnv("$GOPATH"), "src", app.Name ), 0700 )

						if err != nil {
							response = net_bAlert(Alertbs{Type:"danger",Text:"Error creating package " + r.FormValue("name") + ":" + err.Error(),Redirect: "javascript:console.log('error!')"})
						}

					} else {
			    			core.RunCmdB("gos make " + app.Name )
			    	}
				} else {
					app.Type = "app"
				}

				
			    if err == nil{
			    	apps = append(apps, app)
				    //Users.Update(bson.M{"uid": me.UID}, me)
				    methods.SaveApps(apps)
			    	response = net_bAlert(Alertbs{Type:"warning",Text:"Success package " + r.FormValue("name") + " was created!",Redirect: "javascript:updateTree()"})
				}
			} else 	if r.FormValue("type") == "100" {
				plugins := methods.GetPlugins()
			    plugins = append(plugins, r.FormValue("name") )
			   
				
			    //Users.Update(bson.M{"uid": me.UID}, me)
			   
			    _,err :=  core.RunCmdSmart("go get " + r.FormValue("name") )
			    if err != nil {
			    	   response = net_bAlert(Alertbs{Type:"warning",Text:"Error, could not find plugin.",Redirect: "#"})
			    } else {
			    methods.SavePlugins(plugins)
			    response = net_bAlert(Alertbs{Type:"success",Text:"Success plugin " + r.FormValue("name") + " installed! Reload the page to activate plugin.",Redirect: "javascript:GetPlugins()"})
				}
			} else if r.FormValue("type") == "1" {
				
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				//update va
				gos.Update("var", r.FormValue("id"), core.GlobalVariables{Name:r.FormValue("name"),Type: r.FormValue("is")})		

				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				response = "Variable saved!"

			} else if r.FormValue("type") == "2" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				//update var
				gos.Update("import", r.FormValue("id"), core.Import{Src: r.FormValue("src")})			

				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				response = "Import saved!"

			} else if r.FormValue("type") == "3" {
				apps := methods.GetApps()
				app := net_getApp(apps, r.FormValue("pkg"))
				temp := []string{}
				for _,v := range app.Css {
					if v != r.FormValue("id") {
						temp = append(temp, v)
					} else  {
						temp = append(temp, r.FormValue("src"))
					}
				}
				app.Css = temp
				apps = net_updateApp(apps, r.FormValue("pkg"), app)
				methods.SaveApps(apps)
				//Users.Update(bson.M{"uid":me.UID}, me)
			} else if r.FormValue("type") == "4" {
				apps := methods.GetApps()
				app := net_getApp(apps, r.FormValue("pkg"))
				
				app.Groups = append(app.Groups, r.FormValue("name"))
				os.MkdirAll(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/tmpl/" + r.FormValue("name") ,0777 );		
				apps = net_updateApp(apps, r.FormValue("pkg"), app)
				methods.SaveApps(apps)
				//Users.Update(bson.M{"uid":me.UID}, me)	
			} else if r.FormValue("type") == "5" {
				//app := net_getApp(me.Apps, r.FormValue("pkg"))
			  gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				//update var
				os.Create(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/tmpl/" + r.FormValue("bundle") + "/" + r.FormValue("name") + ".tmpl")
				gos.AddS("template", core.Template{Name:r.FormValue("name"),Bundle: r.FormValue("bundle"),TemplateFile:r.FormValue("bundle") + "/" + r.FormValue("name") } )			

				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")			
			} else if r.FormValue("type") == "6" {

				if r.FormValue("fmode") == "touch" {

					os.Create( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web" + r.FormValue("prefix") + "/" + r.FormValue("path") );

				} else if r.FormValue("fmode") == "dir" {
					fmt.Println(os.MkdirAll( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web" + r.FormValue("prefix") + "/" + r.FormValue("path"), 0777 ));				
				} else if r.FormValue("fmode") == "upload" {
					ioutil.WriteFile(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web" + r.FormValue("prefix") + "/" + r.FormValue("path"), core.Decode64(nil,[]byte(r.FormValue("basesix"))),0777)
				}

			} else if r.FormValue("type") == "60" {

				if r.FormValue("fmode") == "touch" {
					addstr := ""
					if !strings.Contains(r.FormValue("path"),".go") {
						addstr = ".go"
					}
					_, err := os.Create( filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" , r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") + addstr ) );

					if err != nil {
						npath := strings.Split(r.FormValue("path"), "/")
							os.MkdirAll( filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , strings.Join(npath[:len(npath) - 1], "/") ),0777 );
							os.Create(  filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") + addstr ) );

					}

				} else if r.FormValue("fmode") == "dir" {
					os.MkdirAll(  filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") ) ,0777 ) ;				
				} else if r.FormValue("fmode") == "upload" {
					ioutil.WriteFile( filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") ), core.Decode64(nil,[]byte(r.FormValue("basesix"))),0777)
				}

			} else if r.FormValue("type") == "61" {

				if r.FormValue("fmode") == "touch" {
					addstr := ""
					if !strings.Contains(r.FormValue("path"),".yml") {
						addstr = ".yml"
					}
					_, err := os.Create( filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" , r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") + addstr ) );

					if err != nil {
						npath := strings.Split(r.FormValue("path"), "/")
							os.MkdirAll( filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , strings.Join(npath[:len(npath) - 1], "/") ),0777 );
							os.Create(  filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") + addstr ) );

					}

				} else if r.FormValue("fmode") == "dir" {
					os.MkdirAll(  filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") ) ,0777 ) ;				
				} else if r.FormValue("fmode") == "upload" {
					ioutil.WriteFile( filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") , r.FormValue("path") ), core.Decode64(nil,[]byte(r.FormValue("basesix"))),0777)
				}

			} else if r.FormValue("type") == "62" {

				os.Chdir( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") )

				name := strings.ToLower(strings.Replace(r.FormValue("name"), "/", "_", -1))

				ioutil.WriteFile("./faas-gen.sh", []byte("#!/bin/sh\n\nfaas-cli new --lang go " + name + " &>faas-log.txt &disown"), 0700 )

				logFull, err := core.RunCmdSmart("sh ./faas-gen.sh")

				if err != nil {
					response = net_bAlert(Alertbs{Type:"danger",Text:"Failed to add function: " + err.Error() + logFull})
				} else {
					
					apps := methods.GetApps()
					app := net_getApp(methods.GetApps(), r.FormValue("pkg"))
					app.Groups = append(app.Groups, r.FormValue("name"))
					apps = net_updateApp(methods.GetApps(), r.FormValue("pkg"), app)
					methods.SaveApps(apps)
					response = net_bAlert(Alertbs{Type:"success",Text:"Operation succeeded, one moment, generating function source.<script>setTimeout(updateTree , 8200)</script>"})
				}	

			} else if r.FormValue("type") == "7" {
					 err := os.Rename( os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web" + r.FormValue("prefix") , os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web/" + r.FormValue("path"))

					if err != nil {
					response = net_bAlert(Alertbs{Type:"danger",Text:"Failed to move resource : " + err.Error()})
					} else {
					response = net_bAlert(Alertbs{Type:"success",Text:"Operation succeeded"})				
					}			

			} else if r.FormValue("type") == "70" {
					 err := os.Rename( filepath.Join(os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , r.FormValue("prefix") ) , filepath.Join( os.ExpandEnv("$GOPATH") , "/src/" ,  r.FormValue("pkg") , "/" , r.FormValue("path") ) )
					if err != nil {
					response = net_bAlert(Alertbs{Type:"danger",Text:"Failed to move resource : " + err.Error()})
					} else {
					response = net_bAlert(Alertbs{Type:"success",Text:"Operation succeeded"})				
					}
			}
				</end>
				
				<end path="/api/breakpoints" type="POST">

					id := r.FormValue("id")
					m := make(map[string]string)
					
					var pkgpath = core.TrimSuffix(os.ExpandEnv("$GOPATH"), "/")+"/src/"+ id +"/"

					if Windows {
						pkgpath = strings.Replace(pkgpath,"/", "\\", -1)
					}

					_ = filepath.Walk(pkgpath, func(path string, file os.FileInfo, _ error) error {
						//fmt.Println(path)
						if file.IsDir() {

							files, _ := ioutil.ReadDir(path)

							for _, f := range files {
								if !f.IsDir() && strings.Contains(f.Name(), "go-breakpoints") {
									var mjk string

									mjk = strings.Replace(path, pkgpath, "",-1) + "/" + f.Name() 
									if Windows {
										mjk = strings.Replace(mjk, "/", "\\", -1)
									}

									data,_ := ioutil.ReadFile(filepath.Join(path, f.Name()))

									m[mjk] = string(data)

								}
							}							
						}
		
						return nil
					})

					response = mResponse(m)

				</end>

				<end path="/api/put" method="mPut" type="POST" >
				me := SoftUser{Email:"Strukture user", Username:"Strukture user"}
			 

			if  r.FormValue("type") == "0" {
			
				//fmt.Println(m)
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("id") + "/gos.gxml")

				 gos.Set(r.FormValue("put"), r.FormValue("var")) 
			  //   fmt.Println(gos)
			
						
				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("id") + "/gos.gxml")

			
			} else if r.FormValue("type") == "1" {
				ioutil.WriteFile(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/" + r.FormValue("target"),[]byte(r.FormValue("data")), 0644)
				response = net_bAlert(Alertbs{Type:"warning",Text: r.FormValue("target") + " saved!"})	
			} else if r.FormValue("type") == "2" {
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				 gos.Update("template",r.FormValue("id"), r.FormValue("struct")) 
			    // fmt.Println(gos)
			
						
				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				response = "Template interface saved!"
			} else if r.FormValue("type") == "3" {
				ioutil.WriteFile(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/web" + r.FormValue("target"),[]byte(r.FormValue("data")), 0777)
				
				response = net_bAlert(Alertbs{Type:"warning",Text: r.FormValue("target") + " saved!"})	
			} else if r.FormValue("type") == "30" {
				ioutil.WriteFile(os.ExpandEnv("$GOPATH") + "/src/" +  filepath.Join( r.FormValue("pkg"), r.FormValue("target") ),[]byte(r.FormValue("data")), 0777)
				
				response = net_bAlert(Alertbs{Type:"warning",Text: r.FormValue("target") + " saved!"})	
			} else if r.FormValue("type") == "4" {

				 filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/structs.dsl"
				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				 ioutil.WriteFile(filep,[]byte(r.FormValue("data")),0644 )
				 //marhal and add
				 vgos := core.CreateVGos(filep)
				 //fmt.Println(vgos,"Gos")
				 gos.MStructs(vgos.Structs)
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				 response = net_bAlert(Alertbs{Type:"warning",Text:"Interfaces saved!"})	

			} else if r.FormValue("type") == "5" {

				 filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/objects.dsl"
				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				 ioutil.WriteFile(filep,[]byte(r.FormValue("data")),0644 )
				 //marhal and add
				 vgos := core.CreateVGos(filep)
				 //fmt.Println(vgos,"Gos")
				 gos.MObjects(vgos.Objects)
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				 response = net_bAlert(Alertbs{Type:"warning",Text:"Objects saved!"})	

			} else if r.FormValue("type") == "6" {

				 filep := os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/methods.dsl"
				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				 ioutil.WriteFile(filep,[]byte(r.FormValue("data")),0644 )
				 //marhal and add
				 vgos := core.CreateVGos(filep)
				 //fmt.Println(vgos,"Gos")
				 gos.MMethod(vgos.Methods)
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")

				 response = net_bAlert(Alertbs{Type:"warning",Text:"Pipelines saved!"})	

			} else if r.FormValue("type") == "7" {

				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/gos.gxml")
				 //write file
				
				 gos.Add("end","",r.FormValue("path"))
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/gos.gxml")				

			}  else if r.FormValue("type") == "8" {

				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/gos.gxml")
				 //write file
				
				 gos.Add("timer","",r.FormValue("name"))
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("space") + "/gos.gxml")				
			}  else if r.FormValue("type") == "9" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				
				 gos.Update("end",r.FormValue("id"), core.Endpoint{Path:r.FormValue("path"),Type:r.FormValue("typ")})
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")	

				response = "OK"

			}  else if r.FormValue("type") == "13r" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				
				 gos.UpdateMethod(r.FormValue("target"), r.FormValue("data"))
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")	

				response = net_bAlert(Alertbs{Type:"warning",Text:"Endpoint code saved!"})

			}  else if r.FormValue("type") == "10" {

				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				
				 gos.Update("timer",r.FormValue("id"), core.Timer{Name:r.FormValue("name"),Method: r.FormValue("method"),Unit:r.FormValue("unit"),Interval:r.FormValue("interval")})
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")	


				response = "OK"
			} else if r.FormValue("type") == "11" {

				hasher := sha512.New512_256()

				if string(hasher.Sum([]byte(r.FormValue("cpassword")))) == string(me.Password) {
					me.Password = hasher.Sum([]byte(r.FormValue("npassword")))
					response = net_bAlert(Alertbs{Type:"success",Text:"Password updated"})
				} else {
					 response = net_bAlert(Alertbs{Type:"danger",Text:"Error incorrect current password"})
				}

			} else if r.FormValue("type") == "12" {
				me.Email = r.FormValue("email")
				response = net_bAlert(Alertbs{Type:"success",Text:"Email updated"})
			} else if r.FormValue("type") == "13" {
				
				gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				 gos.Main = r.FormValue("data")
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")	

			} else if r.FormValue("type") == "14" {

				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				 gos.Init_Func = r.FormValue("data")
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")	

			} else if r.FormValue("type") == "15" {


				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				 gos.Session = r.FormValue("data")
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")	

			} else if r.FormValue("type") == "16" {

				 gos,_ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
				 //write file
				 gos.Package = r.FormValue("var")
				 gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg") + "/gos.gxml")					

			} else if r.FormValue("type") == "17" {

				gos, _ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" + r.FormValue("pkg") + "/gos.gxml")
				//write file
				gos.Shutdown = r.FormValue("data")
				gos.PSaveGos(os.ExpandEnv("$GOPATH") + "/src/" + r.FormValue("pkg") + "/gos.gxml")

			}
				
				</end>
				<end path="/api/build" method="mBuild" type="GET" >
				
		
			gp := os.ExpandEnv("$GOPATH")
			
		    		os.Chdir( gp + "/src/" +  r.FormValue("pkg") )
		    	    os.Remove( gp + "/src/" +  r.FormValue("pkg") + "/bindata.go")
		    	    os.Remove( gp + "/src/" +  r.FormValue("pkg") + "/application.go")

		    	    var logBuilt string
		    	    passed := false
		    		
		    		if _, err := os.Stat("./gos.gxml"); os.IsNotExist(err) {
						logBuilt,_ = core.RunCmdSmart("go build")
						if logBuilt != "" {
							passed = false
						}
					} else {
						logBuilt,_ = core.RunCmdSmart("gos --run --buildcheck")
					}
					fmt.Println(logBuilt)

					

					if !strings.Contains( logBuilt,"Your build failed,") || !passed {
						logBuilt, _ = core.RunCmdSmart("go build")
						if logBuilt != "" {

						debuglog := DebugObj{r.FormValue("pkg"), net_RandTen(), "", logBuilt, time.Now().String(), []DebugNode{} }
			
						logs := strings.Split(logBuilt, "\n")
						
						for linen, log := range logs {
							if linen != 0 {
								linedt := strings.Split( log , ":")
							//	fmt.Println(len(linedt))
								dnode := DebugNode{}
								//fmt.Println(linedt)
								
									//src
								if len(linedt) > 2 {
									dnode.Action = "edit:" + linedt[0] + ":" + linedt[1]
									dnode.CTA = "Update " + linedt[0] + " on line " + linedt[1]
									dnode.Line = strings.Join(linedt[2:], " - ")
									debuglog.Bugs = append(debuglog.Bugs,dnode)
								}
								
								

							}
						}

						methods.AddtoLogs(debuglog)
			response = net_bAlert(Alertbs{Type: "danger", Text: "Your build failed, checkout the logs to see why!"})


						} else {
						passed = true
						response = net_bAlert(Alertbs{Type:"success",Text:"Your build passed!" })
						}
					} else {
					debuglog := DebugObj{r.FormValue("pkg"), net_RandTen(), "", logBuilt, time.Now().String(), []DebugNode{} }
			         fPart := strings.Split(logBuilt,"Full compiler build log :")
						logs := strings.Split(fPart[1], "\n")
						
						for linen, log := range logs {
							if linen != 0 {
								linedt := strings.Split( log , ":")
							//	fmt.Println(len(linedt))
								dnode := DebugNode{}
							//	fmt.Println(linedt)
								if linedt[0] == "./application.go" {
									if len(linedt) > 2 {
									il, _ := strconv.Atoi(linedt[1])
									actline := methods.FindString("./application.go", il )
									actline = strings.TrimSpace(actline)
										//find line
										inStructs := methods.FindLine("./structs.dsl", actline)
										if inStructs == -1 {

											inMethods := methods.FindLine("./methods.dsl", actline)
												if inMethods == -1 {

														gos, _ := core.PLoadGos(os.ExpandEnv("$GOPATH") + "/src/" + r.FormValue("pkg") + "/gos.gxml")

													inMain := methods.FindinString(gos.Main, actline)

													if inMain == -1 {

													inInit := methods.FindinString(gos.
														Init_Func, actline)
													if inInit == -1 {
													//	fmt.Println(actline)
													 for _, v := range gos.Endpoints.Endpoints {

															inEndpoint := methods.FindinString(v.Method, actline)
															if inEndpoint != -1 {
																enode := DebugNode{}
																enode.Action = "service:" + v.Path + " - " + v.Type  + ":" + strconv.Itoa(inEndpoint) + ":" + v.Id
																	enode.Line = strings.Join(linedt[2:], " - ")
																enode.CTA = "Update webservice " + v.Path
																debuglog.Bugs = append(debuglog.Bugs,enode)
															}
														}
													} else {
														linestring := strconv.Itoa(inInit)
														dnode.Action = "init:" + linestring
													dnode.CTA = "Update Init()"
													dnode.Line = strings.Join(linedt[2:], " - ")
													debuglog.Bugs = append(debuglog.Bugs,dnode)
													}

													} else {
														linestring := strconv.Itoa(inMain)
														dnode.Action = "main:" + linestring
													dnode.CTA = "Update main()"
													dnode.Line = strings.Join(linedt[2:], " - ")
								debuglog.Bugs = append(debuglog.Bugs,dnode)
													}
		
												} else {
														linestring := strconv.Itoa(inMethods)
														dnode.Action = "meth:" + linestring
														dnode.CTA = "Update pipelines."
														dnode.Line = strings.Join(linedt[2:], " - ")
														debuglog.Bugs = append(debuglog.Bugs,dnode)
												}

										} else {
											linestring := strconv.Itoa(inStructs)
											dnode.Action = "structs:" + linestring
											dnode.CTA = "Update interfaces."
											dnode.Line = strings.Join(linedt[2:], " - ")
											debuglog.Bugs = append(debuglog.Bugs,dnode)
										}

									}
								} else {
									//src
									if len(linedt) > 2 {
									dnode.Action = "edit:" + linedt[0] + ":" + linedt[1]
									dnode.CTA = "Update " + linedt[0] + " on line " + linedt[1]
									dnode.Line = strings.Join(linedt[2:], " - ")
									debuglog.Bugs = append(debuglog.Bugs,dnode)
									}
								}
								

							}
						}

						methods.AddtoLogs(debuglog)
			response = net_bAlert(Alertbs{Type: "danger", Text: "Your build failed, checkout the logs to see why!"})

		
					}

				//DebugLogs.Insert(dObj)



					apps := methods.GetApps()
					sapp := net_getApp(apps, r.FormValue("pkg"))

					sapp.Passed = passed
					sapp.LatestBuild = time.Now().String()
					apps = net_updateApp(apps, r.FormValue("pkg"), sapp)
					methods.SaveApps(apps)	
					
			//Users.Update(bson.M{"uid":me.UID}, me)
				</end>

				<end path="/api/start"  type="GET" >
				

			gp := os.ExpandEnv("$GOPATH")
			
		    		os.Chdir( gp + "/src/" +  r.FormValue("pkg") )
		    		apps := methods.GetApps()
					sapp := net_getApp(apps, r.FormValue("pkg"))
		    		
					if sapp.Passed {

						if sapp.Pid != ""  {
							core.RunCmdB("kill -3 " + sapp.Pid)
							response = net_bAlert(Alertbs{Type:"success",Text:"Build stopped." })	
						}


		    			pkSpl := strings.Split(r.FormValue("pkg"), "/")
						if Windows {
							go core.RunCmd("cmd /C gos --run") //live reload on windows...
						} else {
						shscript := `#!/bin/bash  
									cmd="./` + pkSpl[len(pkSpl)-1] + ` "
									eval "${cmd}" >main.log &disown
									exit 0`

						ioutil.WriteFile("runsc", []byte(shscript), 0777)
						go core.RunCmdSmart("sh runsc &>/dev/null")
						}

						time.Sleep(time.Second * 5)
						raw, _ := ioutil.ReadFile("main.log")
						lines := strings.Split(string(raw), "\n")
						sapp.Pid = lines[0]
						if Windows {
							response = net_bAlert(Alertbs{Type: "success", Text: "Server up"})
						} else {
						response = net_bAlert(Alertbs{Type: "success", Text: "Your server is up at PID : " + sapp.Pid})
						}	
				} else {
						response = net_bAlert(Alertbs{Type:"danger",Text:"Your latest build failed." })
		
				}

					
				//DebugLogs.Insert(dObj)
				apps = net_updateApp(apps, r.FormValue("pkg"), sapp)
				methods.SaveApps(apps)	
					
			//Users.Update(bson.M{"uid":me.UID}, me)
				</end>

					<end path="/api/stop"  type="GET" >
				

			gp := os.ExpandEnv("$GOPATH")
			
		    	os.Chdir( gp + "/src/" +  r.FormValue("pkg") )
		    	apps := methods.GetApps()
				sapp := net_getApp(apps, r.FormValue("pkg"))
		    		
				if sapp.Pid == "" {
					response = net_bAlert(Alertbs{Type:"danger",Text:"No build running." })
					} else {
						core.RunCmdB("kill -3 " + sapp.Pid)
							response = net_bAlert(Alertbs{Type:"success",Text:"Build stopped." })	
					}

					
				//DebugLogs.Insert(dObj)
				apps = net_updateApp(apps, r.FormValue("pkg"), sapp)
				methods.SaveApps(apps)	
					
			//Users.Update(bson.M{"uid":me.UID}, me)
				</end>
				<end path="/api/bin" method="mBinDL" type="GET" >
				
		
			os.Chdir(os.ExpandEnv("$GOPATH") + "/src/" +  r.FormValue("pkg"))
			os.Remove( strings.Replace(r.FormValue("pkg"), "/",".",-1) + ".binary.zip ")
			bPath := strings.Split(r.FormValue("pkg"), "/")
			gp := os.ExpandEnv("$GOPATH")
			//coreTemplate,_ := core.LoadGos(gp + "/src/" +  r.FormValue("pkg") + "/gos.gxml")
			
			//core.RunCmdB("gos ru " +  r.FormValue("pkg") + " gos.gxml web tmpl")
			os.Remove(gp + "/src/" +  r.FormValue("pkg") + "/server_out.go")

			
			//core.Process(coreTemplate,gp + "/src/" +  r.FormValue("pkg"), "web","tmpl")
			if _, err := os.Stat("./gos.gxml"); os.IsNotExist(err) {
				core.RunCmdB("go build")
			} else {
				core.RunCmdB("gos --export")
			}


			zipname := strings.Replace(r.FormValue("pkg"), "/",".",-1) + ".binary.zip"
			if Windows {
				bPath[len(bPath) - 1]  += ".exe"
				methods.Zipit(bPath[len(bPath) - 1], zipname )
			} else {
				core.RunCmdB("zip -r " + zipname  + " " + bPath[len(bPath) - 1] )
			}
			time.Sleep(500 * time.Millisecond)
			
			
			w.Header().Set("Content-Type",  "application/zip")
			w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", zipname))
			http.ServeFile(w, r,zipname)

				</end>


				<end path="/api/export" method="mExport" type="GET" >
				
	
			os.Chdir(os.ExpandEnv("$GOPATH") + "/src/" )
			os.Remove(strings.Replace(r.FormValue("pkg"), "/",".",-1) + ".zip ")

			if _, err := os.Stat("./gos.gxml"); os.IsNotExist(err) {
				core.RunCmdB("go build")
			} else {
				core.RunCmdB("gos --export")
			}

			pkgpath :=  r.FormValue("pkg") 
			zipname := strings.Replace(r.FormValue("pkg"), "/",".",-1) + ".zip"
			if Windows {
				pkgpath = strings.Replace(pkgpath, "/", "\\", -1)
				methods.Zipit(pkgpath, zipname)
			} else {
				core.RunCmdB("zip -r " + zipname + " " +  pkgpath + "/" )
			}
			time.Sleep(500 * time.Millisecond)
			
			
			w.Header().Set("Content-Type",  "application/zip")
			w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"", zipname))
			http.ServeFile(w, r, strings.Replace(r.FormValue("pkg"), "/",".",-1) + ".zip")
				</end>
				<!-- Wildcard methods -->
				<end path="/api/complete" type="star" >
					
				prefx := r.FormValue("pref")
				
				
				content := r.FormValue("content")
				id := r.FormValue("id")
				tempFile := filepath.Join(autocompletePath, id)

				ioutil.WriteFile(tempFile, []byte(content), 0700)
				cms := "gocode"

				if Windows {
					cms = strings.Replace(os.ExpandEnv("$GOPATH")+"\\bin\\gocode.exe", "/", "\\", -1)
	
				}

				cmd := fmt.Sprintf( cms + " -f=json --in=%s autocomplete %s", tempFile ,prefx)

				res, _ := core.RunCmdSmart(cmd)
				response = res

				
				
				os.Remove(tempFile)

				</end>
			

			<end path="/api/console" method="mConsole" type="POST">
			
				if strings.Contains(r.FormValue("command"), "cd"){
					parts := strings.Fields(r.FormValue("command"))

					if len(parts) == 1 {
						os.Chdir("")
					} else {
						os.Chdir(parts[1])
					}
					if dir,err :=  os.Getwd(); err != nil {
					response = "Changed directory to " + dir
					}

				} else {
					data,err := core.RunCmdSmart(r.FormValue("command") )
					if err !=  nil {
						response = fmt.Sprintf("Error:: %s",err) + "" + data
					} else {
						response = data
					}
				}
				w.Write([]byte(response))
			
			
			response = ""

				</end>
				<end path="/api/terminal_realtime" type="star" >
					c, err := upgrader.Upgrade(w, r, nil)
					if err != nil {
						log.Print("upgrade:", err)
						return
					}
					defer c.Close()

					cm1,cm2 := "bash", "-i"

					if Windows {
						cm1 = "start"
						cm2 = "cmd"
					}

					var ctx exec.ProcessContext

					if Windows {
						tc := strings.Replace("set PATH=%PATH%;" + os.ExpandEnv("$GOPATH") + "\\bin", "/", "\\", -1) 
						
						ctx = exec.InteractiveExec("cmd", "/k", tc)
						c.WriteMessage(1, []byte("HELLO Windows user."))
					} else {
						ctx = exec.InteractiveExec(cm1, cm2)
					}

			        reader :=  methods.Reader{Conn : c}
			        go ctx.Receive(&reader, 5*time.Hour)
			        

					for {
						_, message, err := c.ReadMessage()
						if err != nil {
							log.Println("read:", err)

							if ctx != nil {
								ctx.Cancel()
								ctx.Stop()
							}

							break
						}

						if len(message) != 0 {
							msg := string(message)

							if msg == "killnow\n" {
							fmt.Println("Restarting")
							ctx.Cancel()
							ctx.Stop()
							if Windows {
									tc := strings.Replace("set PATH=%PATH%;" + os.ExpandEnv("$GOPATH") + "\\bin", "/", "\\", -1) 
						
									ctx = exec.InteractiveExec("cmd", "/k", tc)
									c.WriteMessage(1, []byte("HELLO Windows user."))
							} else {
								ctx = exec.InteractiveExec(cm1, cm2)
							}
							reader = methods.Reader{Conn: c}
							go ctx.Receive(&reader, 5*time.Hour)
							continue

							} else if strings.Contains(msg, "$GOPATH") && Windows {

								msg = strings.ReplaceAll(msg, "$GOPATH", dfd)
								msg = strings.ReplaceAll(msg, "/", "\\")
							}  
								
							ctx.Send(msg)

							
						}
						
					}

				</end> 
				<!-- Auth -->
	 			
		</endpoints>
</gos>
